
#include "MasterKey.h"
#include "DSSE.h"
#include "Keyword_Extraction.h"
#include "Miscellaneous.h"
#include "DSSE_Trapdoor.h"
#include "DSSE_Crypto.h"
#include "DSSE_KeyGen.h"
#include "climits"
#include "Client_DSSE.h"
#include "math.h"
DSSE::DSSE()
{
    // register the PRNG with Fortuna

    int err;
    if((err = register_prng(&fortuna_desc)) != CRYPT_OK)
    {
        printf("Error registering Fortuna PRNG : %s\n", error_to_string(err));
    }

    if((err = find_prng("fortuna")) != CRYPT_OK)
    {
        printf("Invalid PRNG : %s\n", error_to_string(err));
    }

    /* start it */
    if((err = fortuna_start(&prng)) != CRYPT_OK)
    {
        printf("Start error: %s\n", error_to_string(err));
    }

    if((err = fortuna_add_entropy((unsigned char *)seed.c_str(), seed.size(), &prng)) != CRYPT_OK)
    {
        printf("Add_entropy error: %s\n", error_to_string(err));
    }
    if((err = fortuna_ready(&prng)) != CRYPT_OK)
    {
        printf("Ready error: %s\n", error_to_string(err));
    }
}

DSSE::~DSSE()
{
}

/**
 * Function Name: setupData_structure
 *
 * Description:
 * Buid all data structures needed for DSSE (incld. in client and server sides). The encrypted
 * index is stored as files
 *
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param pKeywordCounterArray: (output) counter for each keyword
 * @param pBlockCounterArray: (output) counter for each file
 * @param pBlockStateMatrix: (output) state for each block
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param rFileName: (output) list of distinct files
 * @param path: (intput) location of file collection
 * @param pKey: (input) symmetric keys generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::setupData_structure(TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                              TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                              TYPE_COUNTER *pKeywordCounterArray,
                              TYPE_COUNTER *pBlockCounterArray,
                              MatrixType **pBlockStateMatrix,
                              vector<TYPE_INDEX> &lstFree_column_idx,
                              vector<TYPE_INDEX> &lstFree_row_idx,
                              vector<string> &rFileNames,
                              string path,
                              MasterKey *pKey)
{
    set<string>::iterator iter;

    unsigned char empty_label[6] = "EMPTY";
    unsigned char delete_label[7] = "DELETE";
    hashmap_key_class empty_key = hashmap_key_class(empty_label, 6);
    hashmap_key_class delete_key = hashmap_key_class(delete_label, 7);

    try
    {
        rT_W = TYPE_GOOGLE_DENSE_HASH_MAP(MAX_NUM_KEYWORDS * KEYWORD_LOADING_FACTOR);
        rT_W.max_load_factor(KEYWORD_LOADING_FACTOR);
        rT_W.min_load_factor(0.0);
        rT_W.set_empty_key(empty_key);
        rT_W.set_deleted_key(delete_key);

        rT_F = TYPE_GOOGLE_DENSE_HASH_MAP(MAX_NUM_OF_FILES * KEYWORD_LOADING_FACTOR);
        rT_F.max_load_factor(FILE_LOADING_FACTOR);
        rT_F.min_load_factor(0.0);
        rT_F.set_empty_key(empty_key);
        rT_F.set_deleted_key(delete_key);

        lstFree_column_idx.reserve(MAX_NUM_OF_FILES);
        lstFree_column_idx.clear();
        lstFree_row_idx.reserve(MAX_NUM_KEYWORDS);
        lstFree_row_idx.clear();

        for(TYPE_INDEX j = 0; j < MAX_NUM_KEYWORDS; j++)
            lstFree_row_idx.push_back(j);
        for(TYPE_INDEX j = 0; j < MAX_NUM_OF_FILES; j++)
            lstFree_column_idx.push_back(j);
        for(TYPE_INDEX i = 0; i < MAX_NUM_KEYWORDS; i++)
            pKeywordCounterArray[i] = 1;
        for(TYPE_INDEX i = 0; i < MAX_NUM_OF_FILES / ENCRYPT_BLOCK_SIZE; i++)
            pBlockCounterArray[i] = 1;

        printf("   1.0 Scanning whole database first....");
        this->scanDatabase(rFileNames, keywords_dictionary, rT_W, rT_F, path, pKey);
        if(keywords_dictionary.size() >= MAX_NUM_KEYWORDS)
        {
            printf("Error!\n The encrypted index size is not enough to handle all keywords in the DB, please increase "
                   "the MAX_NUM_KEYWORDS in config.h\n");
            exit(1);
        }

        if(rFileNames.size() >= MAX_NUM_OF_FILES)
        {
            printf("Error!\n The encrypted index size is not enough to handle all files in the DB, please increase the "
                   "MAX_NUM_OF_FILES in config.h\n");
            exit(1);
        }
        printf("OK!\n");
        cout << "# unique kw: " << keywords_dictionary.size() << endl;
        cout << "# unique files: " << rFileNames.size() << endl;

        printf("   1.1. Creating keyword and file pairs...");
        vector<vector<TYPE_INDEX>> kw_file_pair;
        kw_file_pair.reserve(MAX_NUM_OF_FILES);
        for(TYPE_INDEX col = 0; col < MAX_NUM_OF_FILES; col++)
        {
            vector<TYPE_INDEX> tmp;
            kw_file_pair.push_back(tmp);
        }
        auto start = time_now;
        this->createKeyword_file_pair(kw_file_pair, rT_W, rT_F, lstFree_row_idx, lstFree_column_idx, path, pKey);
        printf("OK!\n");
        printf("   1.1. Creating encrypted matrix...");
        this->createEncrypted_matrix_from_kw_file_pair(kw_file_pair, pKeywordCounterArray, pBlockCounterArray, pKey);
        printf("OK!\n");
        auto end = time_now;
        cout << "BUILDING TIME: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << " ms"
             << endl;
#if !defined(DECRYPT_AT_CLIENT_SIDE)
        printf("   1.2. Creating block state matrix...");
        this->createBlock_state_matrix_files();
        printf("OK!\n");
#endif
    }
    catch(exception &e)
    {
        printf("Error!\n");
        exit(1);
    }

    return 0;
}

/**
 * Function Name: searchToken
 *
 * Description:
 * generate search token given a keyword being searched
 *
 * @param pSearchToken: (output) generated search token
 * @param keyword: (input) keyword being searched
 * @param pKeywordCounterArray: (input) keyword counters
 * @param pKey: (input) symmetric keys for data structure encryption
 * @return	0 if successful
 */
int DSSE::searchToken(SEARCH_TOKEN &pSearchToken,
                      string keyword,
                      TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                      TYPE_COUNTER *pKeywordCounterArray,
                      MasterKey *pKey)
{
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE] = {'\0'};
    TYPE_COUNTER keyword_counter;
    unsigned char row_key_input[BLOCK_CIPHER_SIZE] = {'\0'};

    DSSE_KeyGen *dsse_keygen = new DSSE_KeyGen();
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    Miscellaneous misc;
    try
    {
        /* Generates the trapdoor for the keyword to be searched */
        int keyword_length = strlen(keyword.c_str());

        dsse_trapdoor->generateTrapdoor_single_input(
                keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)keyword.c_str(), keyword_length, pKey);

        hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
        if(rT_W[hmap_keyword_trapdoor] != NULL)
            pSearchToken.row_index = rT_W[hmap_keyword_trapdoor];
        else
        {
            pSearchToken.row_index = KEYWORD_NOT_EXIST;
            return 0;
        }
        if(pKeywordCounterArray[pSearchToken.row_index] == ULONG_MAX)
        {
            printf("Error! counter limit exceeded");
            exit(1);
        }
        keyword_counter = pKeywordCounterArray[pSearchToken.row_index];
        memset(row_key_input, 0, sizeof(row_key_input));
        memcpy(row_key_input, &pSearchToken.row_index, sizeof(pSearchToken.row_index));
        memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));

        dsse_keygen->genRow_key(pSearchToken.row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

        if(pKeywordCounterArray[pSearchToken.row_index] > 1)
        {

            keyword_counter = pKeywordCounterArray[pSearchToken.row_index] - 1;
            memset(row_key_input, 0, sizeof(row_key_input));
            memcpy(row_key_input, &pSearchToken.row_index, sizeof(pSearchToken.row_index));
            memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));
            dsse_keygen->genRow_key(pSearchToken.row_old_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

            pSearchToken.hasRow_key = true;
        }
        else
        {
            memset(pSearchToken.row_old_key, 0, BLOCK_CIPHER_SIZE);
            pSearchToken.hasRow_key = false;
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    memset(keyword_trapdoor, 0, TRAPDOOR_SIZE);
    memset(row_key_input, 0, BLOCK_CIPHER_SIZE);
    delete dsse_keygen;
    delete dsse_trapdoor;
    return 0;
}
/**
 * Function Name: search
 *
 * Description:
 * Perform keyword search over DSSE encrypted data structure, given a search token
 *
 * @param rFileIDs: (output) list of file ids in which the keyword being searched appears
 * @param pSearchToken: (input) search token
 * @param I: (input) encrypted data structure
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateMatrix: (input) block states
 * @return	0 if successful
 */

int DSSE::search(vector<TYPE_INDEX> &rFileIDs,
                 SEARCH_TOKEN pSearchToken,
                 MatrixType **I,
                 TYPE_COUNTER *pBlockCounterArray,
                 MatrixType **pBlockStateMatrix)
{
    TYPE_INDEX row = 0, col = 0;
    TYPE_INDEX index = 0;
    int bit_number = 0, bit_value = 0, file_index = 0;
    vector<unsigned char> file_list;
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE];
    unsigned char V[BLOCK_CIPHER_SIZE];
    Miscellaneous misc;
    bool need_reencrypt;

    TYPE_INDEX block_idx;
    int ii, jj;
    if(pSearchToken.row_index < 0)
    {
        printf("Error!!\n");
        exit(1);
    }
    try
    {
        rFileIDs.clear();
        file_list.reserve(MATRIX_COL_SIZE);

        /* Get the row index for the keyword being searched */
        row = pSearchToken.row_index;
        /* Decrypt blocks */
        for(index = 0, block_idx = 0; index < MAX_NUM_OF_FILES; index += ENCRYPT_BLOCK_SIZE, block_idx++)
        {
            col = index / BYTE_SIZE;
            if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
            {
                bit_number = index % BYTE_SIZE;
                for(ii = 0; ii < ENCRYPT_BLOCK_SIZE; ii++, bit_number++)
                {
                    if(BIT_CHECK(&I[row][col].byte_data, bit_number))
                        BIT_SET(&V[0], ii);
                    else
                        BIT_CLEAR(&V[0], ii);
                }
            }
            else
            {
                for(jj = col, ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; jj++, ii++)
                {
                    V[ii] = I[row][jj].byte_data;
                }
            }
            memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
            memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &pBlockCounterArray[block_idx], sizeof(TYPE_COUNTER));
            memcpy(&uchar_counter, &block_idx, sizeof(TYPE_INDEX));

            if(pSearchToken.hasRow_key == false ||
               BIT_CHECK(&pBlockStateMatrix[row][block_idx / BYTE_SIZE].byte_data, block_idx % BYTE_SIZE))
            {
                aes128_ctr_encdec(V, U, pSearchToken.row_key, uchar_counter, ONE_VALUE);
                need_reencrypt = false;
            }
            else
            {
                aes128_ctr_encdec(V, U, pSearchToken.row_old_key, uchar_counter, ONE_VALUE);
                need_reencrypt = true;
            }

            if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
            {
                for(ii = 0; ii < ENCRYPT_BLOCK_SIZE; ii++)
                {
                    if(BIT_CHECK(&U[0], ii))
                        rFileIDs.push_back((index + ii));
                }
            }
            else
            {
                for(ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; ii++)
                {
                    for(bit_number = 0; bit_number < BYTE_SIZE; bit_number++)
                        if(BIT_CHECK(&U[ii], bit_number))
                            rFileIDs.push_back(index + ii * BYTE_SIZE + bit_number);
                }
            }

            /* Set the state bit of this block to 0 */
            BIT_CLEAR(&pBlockStateMatrix[row][block_idx / BYTE_SIZE].byte_data, block_idx % BYTE_SIZE);

            /* Re-encrypt the block with the newest row key if the old row key is used to decrypt before */
            if(need_reencrypt == true)
            {
                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &pBlockCounterArray[block_idx], sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_idx, sizeof(TYPE_INDEX));

                aes128_ctr_encdec(U, V, pSearchToken.row_key, uchar_counter, ONE_VALUE);

                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE) // block size < byte size
                {
                    bit_number = index % BYTE_SIZE;
                    for(ii = 0; ii < ENCRYPT_BLOCK_SIZE; ii++, bit_number++)
                    {
                        if(BIT_CHECK(&V[0], ii))
                            BIT_SET(&I[row][col].byte_data, bit_number);
                        else
                            BIT_CLEAR(&I[row][col].byte_data, bit_number);
                    }
                }
                else
                {
                    for(jj = col, ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; jj++, ii++)
                    {
                        I[row][jj].byte_data = V[ii];
                    }
                }
            }
        }
        file_list.clear();
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    file_list.clear();
    memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
    memset(U, 0, BLOCK_CIPHER_SIZE);
    memset(V, 0, BLOCK_CIPHER_SIZE);

    return 0;
}

/**
 * Function Name: addToken
 *
 * Description:
 * Generate a token for adding file
 *
 * @param new_adding_file_with_path: (input) full filename and path of the adding file
 * @param I_prime: (output) block_data after adding the file
 * @param file_index: (output) index of adding file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param extracted_keyword: (output) uniques keyword being extracted from adding file
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateArray: (input) Block states
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::addToken(string new_adding_file_with_path,
                   MatrixType *I_prime,
                   TYPE_INDEX &file_index,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                   TYPE_KEYWORD_DICTIONARY &extracted_keywords,
                   TYPE_COUNTER *pKeywordCounterArray,
                   TYPE_COUNTER *pBlockCounterArray,
                   bool *pBlockStateArray,
                   vector<TYPE_INDEX> &lstFree_column_idx,
                   vector<TYPE_INDEX> &lstFree_row_idx,
                   MasterKey *pKey)
{

    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen *dsse_keygen = new DSSE_KeyGen();
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX keyword_index;
    TYPE_INDEX row, col;

    TYPE_INDEX idx, ii;

    TYPE_INDEX I_bar_idx, I_bar_row, I_bar_bit_position;
    TYPE_INDEX block_index;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE];

    TYPE_INDEX selectedIdx;
    TYPE_COUNTER keyword_counter;
    TYPE_INDEX size;
    KeywordExtraction *kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType *I_bar;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE], V[BLOCK_CIPHER_SIZE];

    try
    {
        I_bar = new MatrixType[MATRIX_ROW_SIZE / BYTE_SIZE];
        memset(I_bar, 0, MATRIX_ROW_SIZE / BYTE_SIZE);

        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor,
                                                     TRAPDOOR_SIZE,
                                                     (unsigned char *)new_adding_file_with_path.c_str(),
                                                     new_adding_file_with_path.size(),
                                                     pKey);

        hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor] == NULL)
        {
            this->pickRandom_element(selectedIdx, lstFree_column_idx, &prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }

        /* Extract unique keywords */
        kw_ex->extractKeywords(extracted_keywords, new_adding_file_with_path, "");

        for(iter = extracted_keywords.begin(); iter != extracted_keywords.end(); iter++)
        {
            string word = *iter;
            int keyword_len = word.size();

            if(keyword_len > 0)
            {
                dsse_trapdoor->generateTrapdoor_single_input(
                        keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)word.c_str(), keyword_len, pKey);
            }

            hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);

            if(rT_W[hmap_keyword_trapdoor] == NULL)
            {
                this->pickRandom_element(selectedIdx, lstFree_row_idx, &prng);
                rT_W[hmap_keyword_trapdoor] = selectedIdx;
            }

            keyword_index = rT_W[hmap_keyword_trapdoor];
            row = keyword_index / BYTE_SIZE;
            bit_position = keyword_index % BYTE_SIZE;

            BIT_SET(&I_bar[row].byte_data, bit_position);

            word.clear();
        }

        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
        ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
        bit_position = file_index % BYTE_SIZE;
        TYPE_COUNTER next_counter = pBlockCounterArray[block_index] + 1;

        if(ENCRYPT_BLOCK_SIZE > 1) // decrypt the received I' to update the new data representation I_bar to I'
        {
            /*
             * 1.(a-c)Decrypt the whole data block I' to be I_bar using block key and the corresponding row key
             * */
            for(I_bar_idx = 0, idx = 0, size = MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE; idx < size;
                idx += ENCRYPT_BLOCK_SIZE, I_bar_idx++)
            {
                row = idx / ENCRYPT_BLOCK_SIZE;
                I_bar_row = I_bar_idx / BYTE_SIZE;
                I_bar_bit_position = I_bar_idx % BYTE_SIZE;
                // *****************  FIX THE ERROR OF VARIANT 1 SHOWN IN THE SAC 2015 **********************
                // if the counter > 1 and the row has not been updated right before, generate the old row key to decrypt
                // it
                if(pKeywordCounterArray[row] > 1 && pBlockStateArray[row] == ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row] - 1;
                }
                else
                {
                    keyword_counter = pKeywordCounterArray[row];
                }
                memset(row_key_input, 0, sizeof(row_key_input));
                memcpy(row_key_input, &row, sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));

                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &pBlockCounterArray[block_index], sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_index, sizeof(TYPE_INDEX));

                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    for(bit_position = idx % BYTE_SIZE, col = idx / BYTE_SIZE, ii = 0; ii < ENCRYPT_BLOCK_SIZE;
                        ii++, bit_position++)
                    {
                        if(BIT_CHECK(&I_prime[col].byte_data, bit_position))
                            BIT_SET(&U[0], ii);
                        else
                            BIT_CLEAR(&U[0], ii);
                    }
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);

                    bit_position = file_index % ENCRYPT_BLOCK_SIZE;

                    if(BIT_CHECK(&I_bar[I_bar_row].byte_data, I_bar_bit_position))
                        BIT_SET(&V[0], bit_position);
                    else
                        BIT_CLEAR(&V[0], bit_position);
                }
                else
                {
                    for(ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; ii++)
                        U[ii] = I_prime[row * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE) + ii].byte_data;

                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);

                    // Update decrypted I_prime (V) by I_bar
                    ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
                    bit_position = file_index % BYTE_SIZE;

                    if(BIT_CHECK(&I_bar[I_bar_row].byte_data, I_bar_bit_position))
                        BIT_SET(&V[ii], bit_position);
                    else
                        BIT_CLEAR(&V[ii], bit_position);
                }
                // Re-encrypt V to U with new key and new counter
                if(pKeywordCounterArray[row] > 1 && pBlockStateArray[row] == ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row];
                    memset(row_key_input, 0, sizeof(row_key_input));
                    memcpy(row_key_input, &row, sizeof(row));
                    memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));
                    dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                }
                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &next_counter, sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_index, sizeof(TYPE_INDEX));

                aes128_ctr_encdec(V, U, row_key, uchar_counter, ONE_VALUE);

                // put U back to I_prime
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    for(bit_position = idx % BYTE_SIZE, col = idx / BYTE_SIZE, ii = 0; ii < ENCRYPT_BLOCK_SIZE;
                        ii++, bit_position++)
                    {
                        if(BIT_CHECK(&U[0], ii))
                            BIT_SET(&I_prime[col].byte_data, bit_position);
                        else
                            BIT_CLEAR(&I_prime[col].byte_data, bit_position);
                    }
                }
                else
                {
                    for(ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; ii++)
                        I_prime[row * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE) + ii].byte_data = U[ii];
                }
            }
        }
        else
        {
            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                keyword_counter = pKeywordCounterArray[row];
                memset(row_key_input, 0, sizeof(row_key_input));
                memcpy(row_key_input, &row, sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));

                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &next_counter, sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_index, sizeof(TYPE_INDEX));

                I_bar_row = row / BYTE_SIZE;
                I_bar_bit_position = row % BYTE_SIZE;
                if(BIT_CHECK(&I_bar[I_bar_row].byte_data, I_bar_bit_position))
                    BIT_SET(&U[0], 0);
                else
                    BIT_CLEAR(&U[0], 0);

                aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);

                if(BIT_CHECK(&V[0], 0))
                    BIT_SET(&I_bar[I_bar_row].byte_data, I_bar_bit_position);
                else
                    BIT_CLEAR(&I_bar[I_bar_row].byte_data, I_bar_bit_position);
            }
            memcpy(I_prime, I_bar, MATRIX_ROW_SIZE / BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete I_bar;

    return 0;
}

/**
 * Function Name: addToken
 *
 * Description:
 * Update block data for adding file using precomputed keys
 * (This function is used when the DECRYPT_AT_CLIENT_SIDE macro is enabled)
 *
 * @param new_adding_file_with_path: (input) full filename and path of the adding file
 * @param I_prime: (output) block_data after adding the file
 * @param file_index: (output) index of adding file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param extracted_keyword: (output) uniques keyword being extracted from adding file
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param decrypt_key_arr: (input)keys used to decrypt input data
 * @param reencrypt_key_arr: (input) keys used to re-encrypt updated data
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::addToken(string new_adding_file_with_path,
                   MatrixType *I_prime,
                   TYPE_INDEX &file_index,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                   TYPE_KEYWORD_DICTIONARY &extracted_keywords,
                   unsigned char *decrypt_key_arr,
                   unsigned char *reencrypt_key_arr,
                   vector<TYPE_INDEX> &lstFree_column_idx,
                   vector<TYPE_INDEX> &lstFree_row_idx,
                   MasterKey *pKey)
{
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen *dsse_keygen = new DSSE_KeyGen();
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX keyword_index;
    TYPE_INDEX row;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE];

    TYPE_INDEX selectedIdx;
    KeywordExtraction *kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType *I_bar;
    MatrixType *decrypted_block;

    try
    {
        decrypted_block = new MatrixType[MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE];

        I_bar = new MatrixType[MATRIX_ROW_SIZE / BYTE_SIZE];
        memset(I_bar, 0, MATRIX_ROW_SIZE / BYTE_SIZE);

        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor,
                                                     TRAPDOOR_SIZE,
                                                     (unsigned char *)new_adding_file_with_path.c_str(),
                                                     new_adding_file_with_path.size(),
                                                     pKey);

        hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor] == NULL)
        {
            this->pickRandom_element(selectedIdx, lstFree_column_idx, &prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }

        /* Extract unique keywords */
        kw_ex->extractKeywords(extracted_keywords, new_adding_file_with_path, "");

        for(iter = extracted_keywords.begin(); iter != extracted_keywords.end(); iter++)
        {
            string word = *iter;
            int keyword_len = word.size();

            if(keyword_len > 0)
            {
                dsse_trapdoor->generateTrapdoor_single_input(
                        keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)word.c_str(), keyword_len, pKey);
            }
            hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
            if(rT_W[hmap_keyword_trapdoor] == NULL)
            {
                this->pickRandom_element(selectedIdx, lstFree_row_idx, &prng);
                rT_W[hmap_keyword_trapdoor] = selectedIdx;
            }
            keyword_index = rT_W[hmap_keyword_trapdoor];
            row = keyword_index / BYTE_SIZE;
            bit_position = keyword_index % BYTE_SIZE;

            BIT_SET(&I_bar[row].byte_data, bit_position);

            word.clear();
        }
        file_index = rT_F[hmap_file_trapdoor];

        if(ENCRYPT_BLOCK_SIZE > 1)
        {
            // decrypt the input block first
            memset(decrypted_block, 0, MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE);
            dsse_keygen->enc_dec_preAESKey(
                    decrypted_block, I_prime, decrypt_key_arr, MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE);

            // update the decrypted block with newly adding file block
            this->updateBlock(I_bar, decrypted_block, file_index);

            // reencrypt the updated blocks with reenncryption key
            dsse_keygen->enc_dec_preAESKey(
                    I_prime, decrypted_block, reencrypt_key_arr, MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE);
        }
        else
        {
            dsse_keygen->enc_dec_preAESKey(I_prime, I_bar, reencrypt_key_arr, MATRIX_ROW_SIZE / BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete decrypted_block;
    delete I_bar;

    return 0;
}

/**
 * Function Name: delToken
 *
 * Description:
 * Generate a token for deleting file
 *
 * @param del_file_with_path: (input) full filename and path of the deleting file
 * @param I_prime: (output) block_data after deleting the file
 * @param file_index: (output) index of deleting file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateArray: (input) Block states
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::delToken(string del_file_with_path,
                   MatrixType *I_prime,
                   TYPE_INDEX &file_index,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                   TYPE_COUNTER *pKeywordCounterArray,
                   TYPE_COUNTER *pBlockCounterArray,
                   bool *pBlockStateArray,
                   vector<TYPE_INDEX> &lstFree_column_idx,
                   vector<TYPE_INDEX> &lstFree_row_idx,
                   MasterKey *pKey)
{

    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen *dsse_keygen = new DSSE_KeyGen();
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX row, col;

    TYPE_INDEX idx, ii;

    TYPE_INDEX I_bar_idx, I_bar_row, I_bar_bit_position;
    TYPE_INDEX block_index;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];

    TYPE_COUNTER keyword_counter;
    TYPE_INDEX size;
    KeywordExtraction *kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType *I_bar;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE], V[BLOCK_CIPHER_SIZE];

    try
    {
        I_bar = new MatrixType[MATRIX_ROW_SIZE / BYTE_SIZE];
        memset(I_bar, 0, MATRIX_ROW_SIZE / BYTE_SIZE);

        dsse_trapdoor->generateTrapdoor_single_input(
                file_trapdoor, TRAPDOOR_SIZE, (unsigned char *)del_file_with_path.c_str(), del_file_with_path.size(), pKey);

        hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);

        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
        TYPE_COUNTER next_counter = pBlockCounterArray[block_index] + 1;

        /* Remove the file trapdoor entry from the file hashmap */
        lstFree_column_idx.push_back(file_index);
        rT_F.erase(hmap_file_trapdoor);

        if(ENCRYPT_BLOCK_SIZE > 1) // decrypt the received I' to update the new data representation I_bar to I'
        {
            /* Decrypt the whole data block I' to be I_bar using block key and the corresponding row key  */
            for(I_bar_idx = 0, idx = 0, size = MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE; idx < size;
                idx += ENCRYPT_BLOCK_SIZE, I_bar_idx++)
            {
                row = idx / ENCRYPT_BLOCK_SIZE;
                I_bar_row = I_bar_idx / BYTE_SIZE;
                I_bar_bit_position = I_bar_idx % BYTE_SIZE;
                // *****************  FIX THE ERROR OF VARIANT 1 SHOWN IN THE SAC 2015 **********************
                // if the counter > 1 and the row has not been updated right before, generate the old row key to decrypt
                // it
                if(pKeywordCounterArray[row] > 1 && pBlockStateArray[row] == ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row] - 1; // rk_stream = input of G_k3 ( i || st_i )
                }
                else
                {
                    keyword_counter = pKeywordCounterArray[row];
                }
                memset(row_key_input, 0, sizeof(row_key_input));
                memcpy(row_key_input, &row, sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &pBlockCounterArray[block_index], sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_index, sizeof(TYPE_INDEX));

                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    for(bit_position = idx % BYTE_SIZE, col = idx / BYTE_SIZE, ii = 0; ii < ENCRYPT_BLOCK_SIZE;
                        ii++, bit_position++)
                    {
                        if(BIT_CHECK(&I_prime[col].byte_data, bit_position))
                            BIT_SET(&U[0], ii);
                        else
                            BIT_CLEAR(&U[0], ii);
                    }
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);

                    // Update decrypted I_prime (V) by 0
                    bit_position = file_index % ENCRYPT_BLOCK_SIZE;
                    BIT_CLEAR(&V[0], bit_position);
                }
                else
                {
                    for(ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; ii++)
                        U[ii] = I_prime[row * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE) + ii].byte_data;

                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);

                    // Update decrypted I_prime (V) by 0
                    ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
                    bit_position = file_index % BYTE_SIZE;

                    BIT_CLEAR(&V[ii], bit_position);
                }
                // Re-encrypt V to U with new key and new counter
                if(pKeywordCounterArray[row] > 1 && pBlockStateArray[row] == ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row];
                    memset(row_key_input, 0, sizeof(row_key_input));
                    memcpy(row_key_input, &row, sizeof(row));
                    memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));

                    dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                }
                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &next_counter, sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_index, sizeof(TYPE_INDEX));

                aes128_ctr_encdec(V, U, row_key, uchar_counter, ONE_VALUE);

                // put U back to I_prime
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    // write the decrypted V back
                    for(bit_position = idx % BYTE_SIZE, col = idx / BYTE_SIZE, ii = 0; ii < ENCRYPT_BLOCK_SIZE;
                        ii++, bit_position++)
                    {
                        if(BIT_CHECK(&U[0], ii))
                            BIT_SET(&I_prime[col].byte_data, bit_position);
                        else
                            BIT_CLEAR(&I_prime[col].byte_data, bit_position);
                    }
                }
                else
                {
                    for(ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; ii++)
                        I_prime[row * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE) + ii].byte_data = U[ii];
                }
            }
        }
        else
        {
            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                keyword_counter = pKeywordCounterArray[row];
                memset(row_key_input, 0, sizeof(row_key_input));
                memcpy(row_key_input, &row, sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &keyword_counter, sizeof(keyword_counter));
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

                memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &next_counter, sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter, &block_index, sizeof(TYPE_INDEX));

                I_bar_row = row / BYTE_SIZE;
                I_bar_bit_position = row % BYTE_SIZE;

                BIT_CLEAR(&U[0], 0);
                // encrypt
                aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);

                if(BIT_CHECK(&V[0], 0))
                    BIT_SET(&I_bar[I_bar_row].byte_data, I_bar_bit_position);
                else
                    BIT_CLEAR(&I_bar[I_bar_row].byte_data, I_bar_bit_position);
            }
            memcpy(I_prime, I_bar, MATRIX_ROW_SIZE / BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete I_bar;

    return 0;
}

/**
 * Function Name: delToken
 *
 * Description:
 * Update block data for deleting file
 * (This function is used when the DECRYPT_AT_CLIENT_SIDE macro is enabled)
 *
 * @param del_file_with_path: (input) full filename and path of the deleting file
 * @param I_prime: (output) block_data after deleting the file
 * @param file_index: (output) index of deleting file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param decrypt_key_arr: (input)keys used to decrypt input data
 * @param reencrypt_key_arr: (input) keys used to re-encrypt updated data
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::delToken(string del_file_with_path,
                   MatrixType *I_prime,
                   TYPE_INDEX &file_index,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                   TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                   unsigned char *decrypt_key_arr,
                   unsigned char *reencrypt_key_arr,
                   vector<TYPE_INDEX> &lstFree_column_idx,
                   vector<TYPE_INDEX> &lstFree_row_idx,
                   MasterKey *pKey)
{
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    Miscellaneous misc;
    DSSE_KeyGen *dsse_keygen = new DSSE_KeyGen();
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    MatrixType *decrypted_block;
    MatrixType *I_bar;
    try
    {

        I_bar = new MatrixType[MATRIX_ROW_SIZE / BYTE_SIZE];
        memset(I_bar, 0, MATRIX_ROW_SIZE / BYTE_SIZE);

        dsse_trapdoor->generateTrapdoor_single_input(
                file_trapdoor, TRAPDOOR_SIZE, (unsigned char *)del_file_with_path.c_str(), del_file_with_path.size(), pKey);

        hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);

        file_index = rT_F[hmap_file_trapdoor];

        /* Remove the file trapdoor entry from the file hashmap */
        lstFree_column_idx.push_back(file_index);
        rT_F.erase(hmap_file_trapdoor);

        if(ENCRYPT_BLOCK_SIZE > 1)
        {
            // decrypt the input block first
            decrypted_block = new MatrixType[MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE];
            memset(decrypted_block, 0, MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE);
            dsse_keygen->enc_dec_preAESKey(
                    decrypted_block, I_prime, decrypt_key_arr, MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE);

            // update the decrypted block with 0-block
            this->updateBlock(I_bar, decrypted_block, file_index);

            // reencrypt the updated blocks with reenncryption key
            dsse_keygen->enc_dec_preAESKey(
                    I_prime, decrypted_block, reencrypt_key_arr, MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE / BYTE_SIZE);
            delete decrypted_block;
        }
        else
        {
            // reencrypt the updated blocks with reenncryption key
            dsse_keygen->enc_dec_preAESKey(I_prime, I_bar, reencrypt_key_arr, MATRIX_ROW_SIZE / BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete I_bar;
    delete dsse_keygen;

    return 0;
}

/**
 * Function Name: update
 *
 * Description:
 * Update the DSSE encrypted data structure, given a adding-file/deleting-file token
 *
 * @param I_prime: (input) block data being updated
 * @param block_index: (input) index of the block being updated
 * @param I: (output) DSSE encrypted data structure after update
 * @param pBlockCounterArray: (output) Block counters
 * @param pBlockStateMatrix: (output) block states
 * @return	0 if successful
 */
int DSSE::update(MatrixType *I_prime,
                 TYPE_INDEX block_idx,
                 MatrixType **I,
                 TYPE_COUNTER *pBlockCounterArray,
                 MatrixType **pBlockStateMatrix)

{
    TYPE_INDEX row, col;
    TYPE_INDEX idx;
    TYPE_INDEX begin, end;
    TYPE_INDEX I_prime_bit_idx, I_prime_col_idx;
    TYPE_INDEX bit_position;
    TYPE_INDEX bit_number;
    try
    {

        if(ENCRYPT_BLOCK_SIZE > 1)
        {
            if(ENCRYPT_BLOCK_SIZE > BYTE_SIZE)
            {
                begin = block_idx * ENCRYPT_BLOCK_SIZE / BYTE_SIZE;
                end = block_idx * ENCRYPT_BLOCK_SIZE / BYTE_SIZE + ENCRYPT_BLOCK_SIZE / BYTE_SIZE;
                idx = 0;
                for(row = 0; row < MATRIX_ROW_SIZE; row++)
                {
                    for(col = begin; col < end; col++, idx++)
                    {
                        I[row][col].byte_data = I_prime[idx].byte_data;
                    }
                }
            }
            else
            {
                col = block_idx * ENCRYPT_BLOCK_SIZE / BYTE_SIZE;
                bit_position = (block_idx * ENCRYPT_BLOCK_SIZE) % BYTE_SIZE;
                idx = 0;
                for(row = 0; row < MATRIX_ROW_SIZE; row++)
                {
                    for(bit_number = bit_position; bit_number < bit_position + ENCRYPT_BLOCK_SIZE; bit_number++, idx++)
                    {
                        I_prime_col_idx = idx / BYTE_SIZE;
                        I_prime_bit_idx = idx % BYTE_SIZE;
                        if(BIT_CHECK(&I_prime[I_prime_col_idx].byte_data, I_prime_bit_idx))
                            BIT_SET(&I[row][col].byte_data, bit_number);
                        else
                            BIT_CLEAR(&I[row][col].byte_data, bit_number);
                    }
                }
            }
        }
        else
        {
            col = block_idx / (BYTE_SIZE);
            bit_position = block_idx % BYTE_SIZE;
            for(row = 0, idx = 0; row < MATRIX_ROW_SIZE; row++, idx++)
            {
                I_prime_bit_idx = idx % BYTE_SIZE;
                I_prime_col_idx = idx / BYTE_SIZE;
                if(BIT_CHECK(&I_prime[I_prime_col_idx].byte_data, I_prime_bit_idx))
                    BIT_SET(&I[row][col].byte_data, bit_position);
                else
                    BIT_CLEAR(&I[row][col].byte_data, bit_position);
            }
        }
/* Iset the counter of this block to+1, set the state of the block to 1.*/
#if !defined(DECRYPT_AT_CLIENT_SIDE)
        if(pBlockCounterArray != NULL)
            pBlockCounterArray[block_idx] += 1;
        if(pBlockStateMatrix != NULL)
        {
            TYPE_INDEX col = block_idx / BYTE_SIZE;
            TYPE_INDEX bit = block_idx % BYTE_SIZE;
            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                BIT_SET(&pBlockStateMatrix[row][col].byte_data, bit);
            }
        }
#endif
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    return 0;
}

/**
 * Function Name: updateBlock
 *
 * Description:
 * Update the input block with a new column data
 *
 * @param updating_block: (input) the new data which will be used to update a column data in the input block
 * @param input_block: (input) block going to be updated
 * @param update_idx: (input) the index of columns which will be updated in the input block
 * @return	0 if successful
 */

int DSSE::updateBlock(MatrixType *updating_block, MatrixType *input_block, TYPE_INDEX update_idx)
{
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX row, col;
    TYPE_INDEX idx, ii, size;
    TYPE_INDEX I_bar_idx, I_bar_row, I_bar_bit_position;
    if(ENCRYPT_BLOCK_SIZE > 1)
    {
        for(I_bar_idx = 0, idx = 0, size = MATRIX_ROW_SIZE * ENCRYPT_BLOCK_SIZE; idx < size;
            idx += ENCRYPT_BLOCK_SIZE, I_bar_idx++)
        {
            col = idx / BYTE_SIZE;
            row = idx / ENCRYPT_BLOCK_SIZE;
            I_bar_row = I_bar_idx / BYTE_SIZE;
            I_bar_bit_position = I_bar_idx % BYTE_SIZE;

            if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
            {
                bit_position = (idx % BYTE_SIZE) + (update_idx % ENCRYPT_BLOCK_SIZE);

                if(BIT_CHECK(&updating_block[I_bar_row].byte_data, I_bar_bit_position))
                    BIT_SET(&input_block[col].byte_data, bit_position);
                else
                    BIT_CLEAR(&input_block[col].byte_data, bit_position);
            }
            else
            {
                // Update decrypted I_prime (V) by I_bar
                ii = (update_idx % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
                bit_position = update_idx % BYTE_SIZE;

                if(BIT_CHECK(&updating_block[I_bar_row].byte_data, I_bar_bit_position))
                    BIT_SET(&input_block[row * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE) + ii].byte_data, bit_position);
                else
                    BIT_CLEAR(&input_block[row * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE) + ii].byte_data, bit_position);
            }
        }
    }
    else
    {
        memcpy(input_block, updating_block, MATRIX_ROW_SIZE / BYTE_SIZE);
    }
    return 0;
}

/**
 * Function Name: requestBlock_index
 *
 * Description:
 * generate the block index, given a name of file being added
 *
 * @param adding_filename_with_pad: (input) full path and name of the file being added
 * @param block_index: (output) block index of the adding file
 * @param rT_F: (input) file hash table
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::requestBlock_index(string adding_filename_with_pad,
                             TYPE_INDEX &block_index,
                             TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                             vector<TYPE_INDEX> &lstFree_column_idx,
                             MasterKey *pKey)
{
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    TYPE_INDEX file_index;
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    TYPE_INDEX selectedIdx;
    try
    {
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor,
                                                     TRAPDOOR_SIZE,
                                                     (unsigned char *)adding_filename_with_pad.c_str(),
                                                     adding_filename_with_pad.size(),
                                                     pKey);
        hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor] == NULL)
        {
            this->pickRandom_element(selectedIdx, lstFree_column_idx, &prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }
        // Get the file index from the hashmap
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
        if(block_index > NUM_BLOCKS)
        {
            printf("Error!!\n");
            exit(1);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    delete dsse_trapdoor;
    return 0;
}

/**
 * Function Name: pickRandom_element
 *
 * Description:
 * Uniformly select an element at random from a set
 *
 * @param random_element: (output) element being picked
 * @param setIdx: (input) set of indices
 * @param prng: pseudo-random number state according to libtomcrypt
 * @return	0 if successful
 */

int DSSE::pickRandom_element(TYPE_INDEX &random_element, vector<TYPE_INDEX> &setIdx, prng_state *prng)
{
    TYPE_INDEX random_idx;
    unsigned char pseudo_random_number[BLOCK_CIPHER_SIZE];
    int seed_len = BLOCK_CIPHER_SIZE;
    int error = 0;

    TYPE_INDEX tmp;

    memset(pseudo_random_number, 0, BLOCK_CIPHER_SIZE);

    // Generate random number
    fortuna_read(pseudo_random_number, BLOCK_CIPHER_SIZE, prng);

    memcpy(&tmp, &pseudo_random_number[7], sizeof(tmp)); // TAKE A HALF OF PSEUDO RANDOM NUMBER VARIABLE
    random_idx = tmp % setIdx.size();

    random_element = setIdx[random_idx];
    setIdx.erase(setIdx.begin() + random_idx);

    memset(pseudo_random_number, 0, BLOCK_CIPHER_SIZE);
    return 0;
}

/**
 * Function Name: scanDatabase
 *
 * Description:
 * Scan the file collection to determine the total numbers of files and unique keywords being extracted, and to estimate
 *the size of 2 hash tables at client
 *
 * @param rFileName: (output) list of files in the file collection
 * @param rKeywordDictionary: (output) list of unique keywords being extracted
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param path: (input) location of the file collection
 * @param pKey: (input) symmetric keys
 * @return	0 if successful
 */
int DSSE::scanDatabase(vector<string> &rFileNames,
                       TYPE_KEYWORD_DICTIONARY &rKeywordsDictionary,
                       TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                       TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                       string path,
                       MasterKey *pKey)
{

    int keyword_len = 0;
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE], file_trapdoor[TRAPDOOR_SIZE];
    string word;
    DIR *pDir;
    struct dirent *pEntry;
    struct stat file_stat;
    string file_name, file_name_with_path;
    TYPE_KEYWORD_DICTIONARY words_per_file;
    set<string>::iterator iter;
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    try
    {
        if((pDir = opendir(path.c_str())) != NULL)
        {
            while((pEntry = readdir(pDir)) != NULL)
            {
                file_name = pEntry->d_name;
                if(!file_name.compare(".") || !file_name.compare(".."))
                {
                    continue;
                }
                else
                {
                    file_name_with_path = path + pEntry->d_name; // "/" +

                    // If the file is a directory (or is in some way invalid) we'll skip it
                    if(stat(file_name_with_path.c_str(), &file_stat))
                        continue;

                    if(S_ISDIR(file_stat.st_mode))
                    {
                        file_name_with_path.append("/");
                        scanDatabase(rFileNames, rKeywordsDictionary, rT_W, rT_F, file_name_with_path, pKey);
                        continue;
                    }
                    if(file_name_with_path.size() > 0)
                    {
                        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor,
                                                                     TRAPDOOR_SIZE,
                                                                     (unsigned char *)file_name_with_path.c_str(),
                                                                     file_name_with_path.size(),
                                                                     pKey);
                    }
                    else
                        printf("File name is empty\n");

                    hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);

                    rT_F[hmap_file_trapdoor] = FILE_NOT_EXIST; // assign empty values to this

                    rFileNames.push_back(file_name_with_path.c_str());

                    KeywordExtraction *wordext = new KeywordExtraction();
                    wordext->extractKeywords(words_per_file, file_name, path);

                    for(iter = words_per_file.begin(); iter != words_per_file.end(); iter++)
                    {
                        word = *iter;
                        keyword_len = word.size();
                        if(keyword_len > 0)
                        {
                            dsse_trapdoor->generateTrapdoor_single_input(
                                    keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)word.c_str(), keyword_len, pKey);
                            rKeywordsDictionary.insert(word);
                        }
                        else
                        {
                            continue;
                        }
                        hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);

                        rT_W[hmap_keyword_trapdoor] = KEYWORD_NOT_EXIST;

                        // Clearing contents
                        word.clear();
                    }
                    // Clearing contents
                    words_per_file.clear();
                    file_name_with_path.clear();
                }
                // Clearing contents
                file_name.clear();
            }

            closedir(pDir);
        }
        else
        {
            cout << "Could not locate the directory..." << endl;
        }
    }
    catch(exception &e)
    {
        cout << "Error occurred in generate_file_trapdoors function " << e.what() << endl;
    }
    return 0;
}

/**
 * Function Name: createKeyword_file_pair
 *
 * Description:
 * create keyword-file pair from the file collection
 *
 * @param kw_file_pair: (output) list of keyword-file pair being extracted
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param lstFree_keyword_idx: (input) list of empty indices used for keyword (e.g., empty row index)
 * @param lstFree_file_idx: (input) list of empty indices used for file (e.g., empty column index)
 * @param path: (input) location of the file collection
 * @param pKey: (input) key generated by genMasterKey which is used for hash table
 * @return	0 if successful
 */
int DSSE::createKeyword_file_pair(vector<vector<TYPE_INDEX>> &kw_file_pair,
                                  TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                                  TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                                  vector<TYPE_INDEX> &lstFree_keyword_idx,
                                  vector<TYPE_INDEX> &lstFree_file_idx,
                                  string path,
                                  MasterKey *pKey)
{
    int keyword_len = 0;
    TYPE_INDEX row = 0, file_index = 0;
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE];
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    string word;
    DIR *pDir;
    struct dirent *pEntry;
    struct stat file_stat;
    string file_name, file_name_with_path;
    TYPE_KEYWORD_DICTIONARY words_per_file;
    set<string>::iterator iter;

    KeywordExtraction *kw_ex = new KeywordExtraction();
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();

    TYPE_INDEX selectedIdx;
    try
    {
        if((pDir = opendir(path.c_str())) != NULL)
        {
            while((pEntry = readdir(pDir)) != NULL)
            {
                file_name = pEntry->d_name;
                // look into pEntry
                if(!file_name.compare(".") || !file_name.compare(".."))
                {
                    continue;
                }
                else
                {
                    file_name_with_path = path + pEntry->d_name;
                    // If the file is a directory (or is in some way invalid) we'll skip it
                    if(stat(file_name_with_path.c_str(), &file_stat))
                        continue;
                    if(S_ISDIR(file_stat.st_mode))
                    {
                        file_name_with_path.append("/");
                        createKeyword_file_pair(
                                kw_file_pair, rT_W, rT_F, lstFree_keyword_idx, lstFree_file_idx, file_name_with_path, pKey);
                        continue;
                    }
                    if(file_name_with_path.size() > 0)
                    {
                        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor,
                                                                     TRAPDOOR_SIZE,
                                                                     (unsigned char *)file_name_with_path.c_str(),
                                                                     file_name_with_path.size(),
                                                                     pKey);
                    }
                    else
                        printf("File name is empty\n");

                    hashmap_key_class hmap_file_trapdoor(file_trapdoor, TRAPDOOR_SIZE);

                    // Get the file index from the hashmap
                    if(rT_F[hmap_file_trapdoor] == FILE_NOT_EXIST)
                    {
                        this->pickRandom_element(selectedIdx, lstFree_file_idx, &prng);
                        rT_F[hmap_file_trapdoor] = selectedIdx;
                    }

                    kw_ex->extractKeywords(words_per_file, file_name, path);

                    for(iter = words_per_file.begin(); iter != words_per_file.end(); iter++)
                    {
                        word = *iter;
                        keyword_len = word.size();
                        if(keyword_len > 0)
                        {
                            dsse_trapdoor->generateTrapdoor_single_input(
                                    keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)word.c_str(), keyword_len, pKey);
                        }
                        else
                        {
                            continue;
                        }
                        hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);

                        if(rT_W[hmap_keyword_trapdoor] == KEYWORD_NOT_EXIST)
                        {
                            this->pickRandom_element(selectedIdx, lstFree_keyword_idx, &prng);
                            rT_W[hmap_keyword_trapdoor] = selectedIdx;
                        }

                        row = rT_W[hmap_keyword_trapdoor];

                        file_index = rT_F[hmap_file_trapdoor];

                        // build the keyword file pair
                        kw_file_pair[file_index].push_back(row);

                        word.clear();
                    }
                    words_per_file.clear();
                    file_name_with_path.clear();
                }
                file_name.clear();
            }

            closedir(pDir);
        }
        else
        {
            printf("Could not locate the directory...\n");
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    memset(keyword_trapdoor, 0, TRAPDOOR_SIZE);
    memset(file_trapdoor, 0, TRAPDOOR_SIZE);
    word.clear();
    delete pEntry;
    file_name.clear();
    file_name_with_path.clear();
    words_per_file.clear();
    delete kw_ex;
    delete dsse_trapdoor;

    return 0;
}

/**
 * Function Name: createEncrypted_matrix_from_kw_file_pair
 *
 * Description:
 * create the DSSE encrypted data structure from the keyword-file pairs extracted and write it to file named
 *FILENAME_MATRIX (config.h)
 *
 * @param kw_file_pair: (input) list of keyword-file pair being extracted
 * @param row_counter_arr: (input) row counters
 * @param block_counter_arr: (input) column (block) counters
 * @param pKey: (input) key generated by genMasterKey which is used to encrypt DSSE data structure
 * @return	0 if successful
 */
int DSSE::createEncrypted_matrix_from_kw_file_pair(vector<vector<TYPE_INDEX>> &kw_file_pair,
                                                   TYPE_COUNTER *row_counter_arr,
                                                   TYPE_COUNTER *block_counter_arr,
                                                   MasterKey *pKey)
{
    int n;
    TYPE_INDEX curIdx;
    TYPE_INDEX size_row;
    TYPE_INDEX col, row, row_idx;
    TYPE_INDEX vector_idx = 0;
    TYPE_INDEX ii, jj;
    int bit_number;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE / MATRIX_PIECE_COL_SIZE;

    unsigned char U[BLOCK_CIPHER_SIZE];
    unsigned char V[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    TYPE_INDEX block_idx;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    DSSE_KeyGen *dsse_keygen = new DSSE_KeyGen();

    MatrixType **I = new MatrixType *[MATRIX_ROW_SIZE];
    for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m++)
    {
        I[m] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I[m], 0, MATRIX_PIECE_COL_SIZE);
    }

    block_idx = 0;

    for(int i = 0; i < n; i++)
    {
        for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m++)
        {
            memset(I[m], 0, MATRIX_PIECE_COL_SIZE);
        }
        for(curIdx = MATRIX_PIECE_COL_SIZE * i, col = 0; curIdx < MATRIX_PIECE_COL_SIZE * (i + 1); col++, curIdx++)
        {
            for(bit_number = 0; bit_number < BYTE_SIZE; bit_number++)
            {
                vector_idx = curIdx * BYTE_SIZE + bit_number;
                for(row = 0, size_row = kw_file_pair[vector_idx].size(); row < size_row; row++)
                {
                    row_idx = kw_file_pair[vector_idx][row];
                    BIT_SET(&I[row_idx][col].byte_data, bit_number);
                }
            }
        }
        // encrypt block by block, there are two options:
        if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE) // block size < byte size
        {
            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                memcpy(row_key_input, &row, sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &row_counter_arr[row], sizeof(row_counter_arr[row]));

                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

                block_idx = (MATRIX_PIECE_COL_SIZE * BYTE_SIZE / ENCRYPT_BLOCK_SIZE) * i;
                for(jj = 0; jj < MATRIX_PIECE_COL_SIZE * BYTE_SIZE; jj += ENCRYPT_BLOCK_SIZE, block_idx++)
                {
                    col = jj / BYTE_SIZE;
                    for(ii = 0, bit_number = jj % BYTE_SIZE; ii < ENCRYPT_BLOCK_SIZE; ii++, bit_number++)
                    {
                        if(BIT_CHECK(&I[row][col].byte_data, bit_number))
                            BIT_SET(&U[0], ii);
                        else
                            BIT_CLEAR(&U[0], ii);
                    }
                    memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                    memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &block_counter_arr[block_idx], sizeof(TYPE_COUNTER));
                    memcpy(&uchar_counter, &block_idx, sizeof(TYPE_INDEX));
                    // Encrypting the  matrix I using AES CTR 128 function
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    // Write the encryped row back to matrix I
                    for(ii = 0, bit_number = jj % BYTE_SIZE; ii < ENCRYPT_BLOCK_SIZE; ii++, bit_number++)
                    {

                        if(BIT_CHECK(&V[0], ii))
                            BIT_SET(&I[row][col].byte_data, bit_number);
                        else
                            BIT_CLEAR(&I[row][col].byte_data, bit_number);
                    }
                }
            }
        }
        else // encrypt block size > byte_size
        {
            if(ENCRYPT_BLOCK_SIZE % BYTE_SIZE != 0)
            {
                printf("Invalid block size, it should be divisible by 8 and not larger than 128");
                exit(1);
            }

            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                memcpy(row_key_input, &row, sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE / 2], &row_counter_arr[row], sizeof(row_counter_arr[row]));

                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);

                block_idx = (MATRIX_PIECE_COL_SIZE * BYTE_SIZE / ENCRYPT_BLOCK_SIZE) * i;
                for(col = 0; col < MATRIX_PIECE_COL_SIZE; col += (ENCRYPT_BLOCK_SIZE / BYTE_SIZE), block_idx++)
                {
                    for(jj = col, ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; jj++, ii++)
                    {
                        U[ii] = I[row][jj].byte_data;
                    }
                    memset(uchar_counter, 0, BLOCK_CIPHER_SIZE);
                    memcpy(&uchar_counter[BLOCK_CIPHER_SIZE / 2], &block_counter_arr[block_idx], sizeof(TYPE_COUNTER));
                    memcpy(&uchar_counter, &block_idx, sizeof(TYPE_INDEX));
                    // Encrypting the  matrix I using AES CTR 128 function
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    for(jj = col, ii = 0; ii < ENCRYPT_BLOCK_SIZE / BYTE_SIZE; jj++, ii++)
                    {
                        I[row][jj].byte_data = V[ii];
                    }
                }
            }
        }
        // write the matrix to file by spliting it to smaller chunks
        for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m += MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i * MATRIX_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename, gcsMatrixPiecePath, &I[m], MATRIX_PIECE_ROW_SIZE, MATRIX_PIECE_COL_SIZE);
        }
    }

    for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m++)
    {
        delete[] I[m];
    }
    delete[] I;
    return 0;
}

/**
 * Function Name: loadEncrypted_matrix_from_files
 *
 * Description:
 * Load the DSSE encrypted data structure from the file named FILENAME_MATRIX located at gcsMatrixPiecePath (config.h)
 *
 * @param I: (output) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::loadEncrypted_matrix_from_files(MatrixType **I)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE / MATRIX_PIECE_COL_SIZE;
    MatrixType *I_piece = new MatrixType[MATRIX_PIECE_COL_SIZE * MATRIX_ROW_SIZE];
    memset(I_piece, 0, MATRIX_PIECE_COL_SIZE * MATRIX_ROW_SIZE);
    for(int i = 0; i < n; i++)
    {
        for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m += MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i * MATRIX_PIECE_COL_SIZE);
            misc.read_matrix_from_file(filename,
                                       gcsMatrixPiecePath,
                                       &I_piece[m * MATRIX_PIECE_COL_SIZE],
                                       MATRIX_PIECE_ROW_SIZE,
                                       MATRIX_PIECE_COL_SIZE);
        }
        for(col = 0; col < MATRIX_PIECE_COL_SIZE; col++)
        {
            I_col_idx = col + (i * MATRIX_PIECE_COL_SIZE);
            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                I[row][I_col_idx].byte_data = I_piece[row * MATRIX_PIECE_COL_SIZE + col].byte_data;
            }
        }
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: saveEncrypted_matrix_to_files
 *
 * Description:
 * Save the DSSE encrypted data structure to the files named FILENAME_MATRIX located at gcsMatrixPiecePath (config.h)
 *
 * @param I: (input) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::saveEncrypted_matrix_to_files(MatrixType **I)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE / MATRIX_PIECE_COL_SIZE;
    MatrixType *I_piece = new MatrixType[MATRIX_PIECE_COL_SIZE * MATRIX_ROW_SIZE];
    memset(I_piece, 0, MATRIX_PIECE_COL_SIZE * MATRIX_ROW_SIZE);
    for(int i = 0; i < n; i++)
    {
        for(col = 0; col < MATRIX_PIECE_COL_SIZE; col++)
        {
            I_col_idx = col + (i * MATRIX_PIECE_COL_SIZE);
            for(row = 0; row < MATRIX_ROW_SIZE; row++)
            {
                I_piece[row * MATRIX_PIECE_COL_SIZE + col].byte_data = I[row][I_col_idx].byte_data;
            }
        }
        for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m += MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i * MATRIX_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,
                                      gcsMatrixPiecePath,
                                      &I_piece[m * MATRIX_PIECE_COL_SIZE],
                                      MATRIX_PIECE_ROW_SIZE,
                                      MATRIX_PIECE_COL_SIZE);
        }
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: createBlock_state_matrix_files
 *
 * Description:
 * Initialize the block state matrix and save it to files
 *
 * @return	0 if successful
 */
int DSSE::createBlock_state_matrix_files()
{
    int n;
    Miscellaneous misc;
    n = (NUM_BLOCKS / BLOCK_STATE_PIECE_COL_SIZE);
    n = n / BYTE_SIZE;

    MatrixType **I_chunk = new MatrixType *[BLOCK_STATE_PIECE_ROW_SIZE];
    TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;
    for(TYPE_INDEX k = 0; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
    {
        I_chunk[k] = new MatrixType[kk];
    }
    for(int i = 0; i < n; i++)
    {
        cout << endl << i << "...." << endl;
        for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m += BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i * BLOCK_STATE_PIECE_COL_SIZE);
            for(int k = 0; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
            {
                memset(I_chunk[k], 0, kk);
            }
            misc.write_matrix_to_file(filename, gcsMatrixPiecePath, I_chunk, BLOCK_STATE_PIECE_ROW_SIZE, kk);
        }
    }
    for(TYPE_INDEX k = 0; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
    {
        delete[] I_chunk[k];
    }
    delete[] I_chunk;
    return 0;
}

/**
 * Function Name: loadBlock_state_matrix_from_file
 *
 * Description:
 * Load a small-piece of block state matrix from files located gcsMatrixPiecePath (config.h)
 *
 * @param I: (output) Block state matrix
 * @return	0 if successful
 */
int DSSE::loadBlock_state_matrix_from_file(MatrixType **I)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = NUM_BLOCKS / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE;
    MatrixType **I_piece = new MatrixType *[BLOCK_STATE_ROW_SIZE];

    TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;

    for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        I_piece[m] = new MatrixType[kk];
    }
    for(int i = 0; i < n; i++)
    {
        for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m += BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i * BLOCK_STATE_PIECE_COL_SIZE);
            misc.read_matrix_from_file(filename, gcsMatrixPiecePath, &I_piece[m], BLOCK_STATE_PIECE_ROW_SIZE, kk);
        }
        for(col = 0; col < kk; col++)
        {
            I_col_idx = col + (i * kk);
            for(row = 0; row < BLOCK_STATE_ROW_SIZE; row++)
            {
                I[row][I_col_idx] = I_piece[row][col];
            }
        }
    }
    for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        delete[] I_piece[m];
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: saveBlock_state_matrix_to_file
 *
 * Description:
 * Save block state matrix to files located gcsMatrixPiecePath (config.h)
 *
 * @param I: (input) Block state matrix
 * @return	0 if successful
 */
int DSSE::saveBlock_state_matrix_to_file(MatrixType **I)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = NUM_BLOCKS / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE;
    MatrixType **I_piece = new MatrixType *[BLOCK_STATE_ROW_SIZE];

    TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;

    for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        I_piece[m] = new MatrixType[kk];
    }
    for(int i = 0; i < n; i++)
    {
        for(col = 0; col < kk; col++)
        {
            I_col_idx = col + (i * kk);
            for(row = 0; row < BLOCK_STATE_ROW_SIZE; row++)
            {
                I_piece[row][col] = I[row][I_col_idx];
            }
        }
        for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m += BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i * BLOCK_STATE_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename, gcsMatrixPiecePath, &I_piece[m], BLOCK_STATE_PIECE_ROW_SIZE, kk);
        }
    }
    for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        delete[] I_piece[m];
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: getBlock
 *
 * Description:
 * get the block data from the encrypted data structure, given a block index and the dimension
 *
 * @param block_index: (input) block index
 * @param dim: dimension (ROW or COL)
 * @param I_prime: (output) block data
 * @param I: (input) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::getBlock(TYPE_INDEX index, int dim, MatrixType **I, MatrixType *I_prime)
{
    TYPE_INDEX row, col;
    TYPE_INDEX I_prime_col;
    try
    {
        if(dim == COL)
        {
            TYPE_INDEX I_prime_idx = 0;
            TYPE_INDEX begin;
            TYPE_INDEX end;
            if(ENCRYPT_BLOCK_SIZE >= BYTE_SIZE)
            {
                begin = index * (ENCRYPT_BLOCK_SIZE / BYTE_SIZE);
                end = begin + (ENCRYPT_BLOCK_SIZE / BYTE_SIZE);

                for(row = 0; row < MATRIX_ROW_SIZE; row++)
                {
                    for(col = begin; col < end; col++, I_prime_idx++)
                    {
                        I_prime[I_prime_idx].byte_data = I[row][col].byte_data;
                    }
                }
            }
            else
            {
                TYPE_INDEX I_bit_idx, I_prime_bit_idx;
                col = (index * ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
                begin = (index * ENCRYPT_BLOCK_SIZE) % BYTE_SIZE;
                end = begin + ENCRYPT_BLOCK_SIZE;
                for(row = 0; row < MATRIX_ROW_SIZE; row++)
                {
                    for(I_bit_idx = begin; I_bit_idx < end; I_bit_idx++, I_prime_idx++)
                    {
                        I_prime_col = I_prime_idx / BYTE_SIZE;
                        I_prime_bit_idx = I_prime_idx % BYTE_SIZE;

                        if(BIT_CHECK(&I[row][col].byte_data, I_bit_idx))
                            BIT_SET(&I_prime[I_prime_col].byte_data, I_prime_bit_idx);
                        else
                            BIT_CLEAR(&I_prime[I_prime_col].byte_data, I_prime_bit_idx);
                    }
                }
            }
        }
        else
        {
            memcpy(I_prime, I[index], MATRIX_COL_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    return 0;
}

/**
 * Function Name: loadEncrypted_matrix_from_files
 *
 * Description:
 * Load the DSSE encrypted data structure from a corresponding file located at gcsMatrixPiecePath (config.h)
 * This function only loads a single block of encrypted data structure appropriate with the index
 * @param I: (output) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 *
 * @return	0 if successful
 */
int DSSE::loadEncrypted_matrix_from_files(MatrixType **I, int dim, TYPE_INDEX idx)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;

    if(dim == COL)
    {
        // calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx * ENCRYPT_BLOCK_SIZE) / (MATRIX_PIECE_COL_SIZE * BYTE_SIZE) * MATRIX_PIECE_COL_SIZE;
        TYPE_INDEX c = ceil((double)(ENCRYPT_BLOCK_SIZE) / (BYTE_SIZE));

        TYPE_INDEX n1 = (idx * ENCRYPT_BLOCK_SIZE) % (MATRIX_PIECE_COL_SIZE * BYTE_SIZE) / BYTE_SIZE;
        TYPE_INDEX n2 = MATRIX_PIECE_COL_SIZE - n1 - c;
        for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m += MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename, gcsMatrixPiecePath, &I[m], MATRIX_PIECE_ROW_SIZE, c, n1, n2, dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / MATRIX_PIECE_ROW_SIZE) * MATRIX_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % MATRIX_PIECE_ROW_SIZE;
        MatrixType **I_tmp = new MatrixType *[1];
        I_tmp[0] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I_tmp[0], 0, MATRIX_PIECE_COL_SIZE);

        for(TYPE_INDEX n = 0; n < MATRIX_COL_SIZE; n += MATRIX_PIECE_COL_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename, gcsMatrixPiecePath, I_tmp, 1, MATRIX_PIECE_COL_SIZE, m1, 0, dim);
            memcpy(&I[0][n], I_tmp[0], MATRIX_PIECE_COL_SIZE);
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }

    return 0;
}

/**
 * Function Name: saveEncrypted_matrix_to_files
 *
 * Description:
 * Save the DSSE encrypted data structure to a corresponding file located at gcsMatrixPiecePath (config.h)
 * This function only saves a single block of encrypted data structure appropriate with the index
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 *
 * @return	0 if successful
 */
int DSSE::saveEncrypted_matrix_to_files(MatrixType **I, int dim, TYPE_INDEX idx)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    if(dim == COL)
    {
        // calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx * ENCRYPT_BLOCK_SIZE) / (MATRIX_PIECE_COL_SIZE * BYTE_SIZE) * MATRIX_PIECE_COL_SIZE;
        TYPE_INDEX c = ceil((double)(ENCRYPT_BLOCK_SIZE) / (BYTE_SIZE));

        TYPE_INDEX n1 = (idx * ENCRYPT_BLOCK_SIZE) % (MATRIX_PIECE_COL_SIZE * BYTE_SIZE) / BYTE_SIZE;
        TYPE_INDEX n2 = MATRIX_PIECE_COL_SIZE - n1 - c;

        for(TYPE_INDEX m = 0; m < MATRIX_ROW_SIZE; m += MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename, gcsMatrixPiecePath, &I[m], MATRIX_PIECE_ROW_SIZE, c, n1, n2, dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / MATRIX_PIECE_ROW_SIZE) * MATRIX_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % MATRIX_PIECE_ROW_SIZE;
        MatrixType **I_tmp = new MatrixType *[1];
        I_tmp[0] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I_tmp[0], 0, MATRIX_PIECE_COL_SIZE);

        for(TYPE_INDEX n = 0; n < MATRIX_COL_SIZE; n += MATRIX_PIECE_COL_SIZE)
        {
            memcpy(I_tmp[0], &I[0][n], MATRIX_PIECE_COL_SIZE);
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename, gcsMatrixPiecePath, I_tmp, 1, MATRIX_PIECE_COL_SIZE, m1, 0, dim);
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }

    return 0;
}

/**
 * Function Name: saveBlock_state_matrix_to_file
 *
 * Description:
 * Save a single block state matrix to files located gcsMatrixPiecePath (config.h)
 * This function only save a single block state matrix appropriate with the index and dimension
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 *
 * @return	0 if successful
 */
int DSSE::saveBlock_state_matrix_to_file(MatrixType **I, int dim, TYPE_INDEX idx)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;

    if(dim == COL)
    {
        TYPE_INDEX n = (idx / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE) * BLOCK_STATE_PIECE_COL_SIZE;

        TYPE_INDEX n1 = (idx % (BLOCK_STATE_PIECE_COL_SIZE * BYTE_SIZE)) / BYTE_SIZE;
        TYPE_INDEX n2 = BLOCK_STATE_PIECE_COL_SIZE - n1 - 1;

        for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m += BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(
                    filename, gcsMatrixPiecePath, &I[m], BLOCK_STATE_PIECE_ROW_SIZE, 1, n1, n2, dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / BLOCK_STATE_PIECE_ROW_SIZE) * BLOCK_STATE_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % BLOCK_STATE_PIECE_ROW_SIZE;

        MatrixType **I_tmp = new MatrixType *[1];
        I_tmp[0] = new MatrixType[BLOCK_STATE_PIECE_COL_SIZE];
        memset(I_tmp[0], 0, BLOCK_STATE_PIECE_COL_SIZE);

        for(TYPE_INDEX n = 0; n < NUM_BLOCKS / BYTE_SIZE; n += BLOCK_STATE_PIECE_COL_SIZE)
        {
            memcpy(I_tmp[0], &I[0][n], BLOCK_STATE_PIECE_COL_SIZE);
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(
                    filename, gcsMatrixPiecePath, I_tmp, 1, BLOCK_STATE_PIECE_COL_SIZE, m1, 0, dim);
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }

    return 0;
}

/**
 * Function Name: loadBlock_state_matrix_from_file
 *
 * Description:
 * Load a single block state matrix to files located gcsMatrixPiecePath (config.h)
 * This function only load a single block state matrix appropriate with the index and dimension
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 *
 * @return	0 if successful
 */
int DSSE::loadBlock_state_matrix_from_file(MatrixType **I, int dim, TYPE_INDEX idx)
{
    int n;
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;

    if(dim == COL)
    {
        // calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE) * BLOCK_STATE_PIECE_COL_SIZE;
        TYPE_INDEX n1 = (idx % (BLOCK_STATE_PIECE_COL_SIZE * BYTE_SIZE)) / BYTE_SIZE;
        TYPE_INDEX n2 = BLOCK_STATE_PIECE_COL_SIZE - n1 - 1;

        for(TYPE_INDEX m = 0; m < BLOCK_STATE_ROW_SIZE; m += BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(
                    filename, gcsMatrixPiecePath, &I[m], BLOCK_STATE_PIECE_ROW_SIZE, 1, n1, n2, dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / BLOCK_STATE_PIECE_ROW_SIZE) * BLOCK_STATE_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % BLOCK_STATE_PIECE_ROW_SIZE;
        MatrixType **I_tmp = new MatrixType *[1];
        TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;
        I_tmp[0] = new MatrixType[kk];
        memset(I_tmp[0], 0, kk);

        for(TYPE_INDEX n = 0; n < NUM_BLOCKS / BYTE_SIZE; n += BLOCK_STATE_PIECE_COL_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename, gcsMatrixPiecePath, I_tmp, 1, kk, m1, 0, dim);
            memcpy(&I[0][n], I_tmp[0], kk);
        }

        delete[] I_tmp[0];
        delete[] I_tmp;
    }

    return 0;
}
